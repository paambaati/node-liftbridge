import hyperId from 'hyperid';
import { AckPolicy, AckPolicyMap, Message } from '../grpc/generated/api_pb';
import { BuiltinPartitioners, PartitionerLike } from './partition';

/**
 * @hidden
 */
const envelopeMagicNumber = Buffer.from([0xB9, 0x0E, 0x43, 0xB4]);
/**
 * @hidden
 */
const envelopeMagicNumberLength = envelopeMagicNumber.length;
/**
 * @hidden
 */
const envelopeProtoV0 = 0x00;
/**
 * @hidden
 */
const envelopeMinHeaderLength = 8;

/**
 * Liftbridge message headers.
 * @category Message
 */
interface IMessageHeader {
    [key: string]: string;
}

/**
 * Liftbridge message interface.
 * @category Message
 */
export interface IMessage {
    /**
     * Message subject.
     */
    subject?: string;
    /**
     * Key to set on the Message. If Liftbridge has stream compaction enabled,
     * the stream will retain only the last value for each key.
     */
    key?: Uint8Array | string | null;
    /**
     * Value to set on the Message for the key.
     */
    value: Uint8Array | string;
    /**
     * Sets the identifier used to correlate an ack with the
     * published message.
     *
     * Defaults to a unique ID generated by [`hyperid`](https://github.com/mcollina/hyperid/blob/master/README.md).
     */
    correlationId?: string;
    /**
     * Key-value pairs to set on the Message headers map.
     */
    headers?: IMessageHeader;
    /**
     * Sets the NATS subject Liftbridge should publish the message ack
     * to. If it's not set or if there's no Deadline, Liftbridge will not send an ack.
     * This is usually not needed when using the [[publish]] API.
     */
    ackInbox?: string;
    /**
     * Controls the behavior of message acks sent by the server. By
     * default, Liftbridge will send an ack when the stream leader has written
     * the message to its write-ahead log.
     */
    ackPolicy?: AckPolicyMap[keyof AckPolicyMap];
    /**
     * Specifies the stream partition to publish the message to. If
     * this is set, any `partitioner` will not be used. This is a pointer to
     * allow distinguishing between undefined and 0.
     */
    partition?: number | undefined;
    /**
     * Specifies the strategy for mapping a message to a stream partition.
     *
     * Can be either a string (see [[BuiltinPartitioners]]) or a custom implementation
     * of [[BasePartitioner]].
     */
    partitionStrategy?: keyof BuiltinPartitioners | PartitionerLike | undefined;
}

/**
 * Liftbridge message subclass.
 *
 * Includes some helpful methods to convert to/from native JSON objects
 * to Liftbridge gRPC objects.
 *
 * @category Message
 */
export default class LiftbridgeMessage extends Message {
    /**
     * See [[IMessage.correlationId]].
     */
    public correlationId = hyperId().uuid;

    /**
     * See [[IMessage.partition]].
     */
    public partition: number | undefined = undefined;

    /**
     * See [[IMessage.partitionStrategy]].
     */
    public partitionStrategy: keyof BuiltinPartitioners | PartitionerLike | undefined = 'key';

    /**
     * Creates a Message object that is a representation of the gRPC `Message` object.
     * @param message Message object.
     * @returns Message object (with some extra helpful methods).
     */
    constructor(message: IMessage) {
        super();
        if (message.subject) this.setSubject(message.subject);
        this.setValue(typeof message.value === 'string' ? Buffer.from(message.value) : message.value);

        if (message.key) {
            this.setKey(typeof message.key === 'string' ? Buffer.from(message.key) : message.key);
        } else {
            this.setKey(Buffer.from(''));
        }

        if (Object.prototype.hasOwnProperty.call(message, 'partition')) {
            this.partition = message.partition;
            this.partitionStrategy = undefined;
        } else {
            this.partitionStrategy = message.partitionStrategy;
            this.partition = undefined;
        }

        if (Object.prototype.hasOwnProperty.call(message, 'correlationId')) {
            this.setCorrelationid(message.correlationId as string);
        } else {
            this.setCorrelationid(this.correlationId);
        }

        if (Object.prototype.hasOwnProperty.call(message, 'ackPolicy')) {
            this.setAckpolicy(<AckPolicyMap[keyof AckPolicyMap]>message.ackPolicy);
        } else {
            this.setAckpolicy(AckPolicy.NONE);
        }

        if (message.ackInbox) this.setAckinbox(message.ackInbox);

        if (message.headers) {
            const headerKeys = Object.keys(message.headers);
            if (headerKeys.length) {
                headerKeys.forEach(headerKey => {
                    const headerValue = (<IMessageHeader>message.headers)[headerKey] || '';
                    this.getHeadersMap().set(headerKey, Buffer.from(headerValue, 'utf8'));
                });
            }
        }
    }

    /**
     * Create a serialized `Message` object with the Liftbridge envelope.
     *
     * ℹ️ Use only when you're talking directly to NATS systems.
     *
     * @returns Buffer of Protobuf message.
     */
    public serializeMessage(): Buffer {
        const serializedMessage = this.serializeBinary();
        let position = 0;
        const returnMessage = Buffer.from(envelopeMagicNumber, position, envelopeMagicNumberLength + 4 + serializedMessage.length);
        position += envelopeMagicNumberLength;
        returnMessage.write(envelopeProtoV0.toString(), position);
        position += 1;
        returnMessage.write('0x00', position); // Flags.
        position += 1;
        returnMessage.write('0x00', position); // Reserved for future use.
        position += 1;
        if (position !== envelopeMinHeaderLength) {
            // TODO: Throw https://github.com/liftbridge-io/go-liftbridge/blob/6490950e9e465ae75f64feba3de3823a0f744528/message.go#L523
        }
        returnMessage.write(serializedMessage.toString(), position);
        return returnMessage;
    }

    /**
     * Returns a deserialized `Message` in JSON form.
     *
     * Buffers & byte-arrays are deserialized to UTF-8 strings,
     * and maps of the form `[[k1, v1], [k2, v2]]` are converted to
     * objects of the form `{ k1: v1, k2, v2 }`.
     *
     * @param message Liftbridge `Message` to deserialize.
     * @returns JSON form of given `Message` as [[IMessage]].
     */
    public static toJSON(message: Message): IMessage {
        const rawObject = message.toObject();
        const { headersMap, ...messageWithoutHeadersMap } = rawObject;
        return {
            ...messageWithoutHeadersMap,
            key: Buffer.from(rawObject.key.toString(), 'base64').toString('utf8'),
            value: Buffer.from(rawObject.value.toString(), 'base64').toString('utf8'),
            headers: rawObject.headersMap.reduce((k, v) => {
                const nk = { ...k };
                nk[v[0]] = typeof v[1] === 'string' ? v[1] : Buffer.from(v[1]).toString('utf8');
                return nk;
            }, {}),
        };
    }
}

export { AckPolicy } from '../grpc/generated/api_pb';
